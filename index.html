<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- SEO Meta Tags -->
    <title>
      Circle Quest - Draw the Perfect Circle Game | Retro Pixel Art Challenge
    </title>
    <meta
      name="description"
      content="Test your drawing skills in Circle Quest! A fun retro pixel art game where you draw circles and get scored on accuracy. Can you achieve the perfect 100% circle? Play now!"
    />
    <meta
      name="keywords"
      content="circle game, drawing game, perfect circle, pixel art game, retro game, browser game, free online game, circle challenge, drawing skill test"
    />
    <meta name="author" content="Circle Quest" />
    <meta name="robots" content="index, follow" />
    <meta name="theme-color" content="#1a1a2e" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="Circle Quest - Draw the Perfect Circle Game"
    />
    <meta
      property="og:description"
      content="Test your drawing skills! Draw perfect circles in this retro pixel art game. Can you score 100%?"
    />
    <meta
      property="og:image"
      content="https://circle.pragusga.com/preview.png"
    />
    <meta property="og:url" content="https://circle.pragusga.com/" />
    <meta property="og:site_name" content="Circle Quest" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="Circle Quest - Draw the Perfect Circle Game"
    />
    <meta
      name="twitter:description"
      content="Test your drawing skills in this retro pixel art circle drawing game!"
    />
    <meta
      name="twitter:image"
      content="https://circle.pragusga.com/preview.png"
    />

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link
      rel="alternate icon"
      type="image/png"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%231a1a2e'/><circle cx='16' cy='16' r='10' fill='none' stroke='%23ff0080' stroke-width='2'/></svg>"
    />
    <link
      rel="apple-touch-icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect width='180' height='180' fill='%231a1a2e'/><circle cx='90' cy='90' r='60' fill='none' stroke='%23ff0080' stroke-width='8'/><circle cx='90' cy='90' r='70' fill='none' stroke='%2300ffff' stroke-width='4' opacity='0.5'/></svg>"
    />

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

      * {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }

      body {
        font-family: 'Press Start 2P', monospace;
        background: #1a1a2e;
        background-image: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.3) 2px,
          rgba(0, 0, 0, 0.3) 4px
        );
        overflow: hidden;
        height: 100vh;
      }

      .score-display {
        transition: none;
        text-shadow: 4px 4px 0px #000, -2px -2px 0px rgba(255, 255, 255, 0.2);
      }

      #drawingCanvas {
        box-shadow: 6px 6px 0px #000, inset -3px -3px 0px rgba(0, 0, 0, 0.5);
        touch-action: none;
        background: repeating-linear-gradient(
            0deg,
            #f0f0f0 0px,
            #f0f0f0 8px,
            #e8e8e8 8px,
            #e8e8e8 16px
          ),
          repeating-linear-gradient(
            90deg,
            #f0f0f0 0px,
            #f0f0f0 8px,
            #e8e8e8 8px,
            #e8e8e8 16px
          );
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><rect x="6" y="0" width="4" height="16" fill="%23ff0080"/><rect x="0" y="6" width="16" height="4" fill="%23ff0080"/></svg>')
            8 8,
          crosshair;
      }

      .canvas-container {
        max-width: 100vw;
        width: 100%;
        max-width: 400px;
        aspect-ratio: 1 / 1;
        position: relative;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translate(0, 0);
        }
        10% {
          transform: translate(-4px, 4px);
        }
        20% {
          transform: translate(4px, -4px);
        }
        30% {
          transform: translate(-4px, -4px);
        }
        40% {
          transform: translate(4px, 4px);
        }
        50% {
          transform: translate(-4px, 0);
        }
        60% {
          transform: translate(4px, 0);
        }
        70% {
          transform: translate(0, -4px);
        }
        80% {
          transform: translate(0, 4px);
        }
        90% {
          transform: translate(-2px, 2px);
        }
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      @keyframes blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      @keyframes confetti {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-8px);
        }
      }

      .shake {
        animation: shake 0.5s steps(10);
      }

      .pulse {
        animation: pulse 1.5s ease-in-out infinite;
      }

      .confetti {
        position: fixed;
        width: 12px;
        height: 12px;
        animation: confetti 3s linear forwards;
        pointer-events: none;
      }

      /* Pixel art badge styling */
      .best-score-badge {
        background: #ffcc00;
        border: 4px solid #000;
        box-shadow: 4px 4px 0px #000, inset -2px -2px 0px rgba(0, 0, 0, 0.3);
        animation: float 2s ease-in-out infinite;
      }

      /* Pixel button styling */
      .pixel-button {
        border: 3px solid #000;
        box-shadow: 3px 3px 0px #000;
        transition: none;
        position: relative;
      }

      .pixel-button:hover {
        box-shadow: 4px 4px 0px #000;
        transform: translate(-1px, -1px);
      }

      .pixel-button:active {
        box-shadow: 2px 2px 0px #000 !important;
        transform: translate(1px, 1px) !important;
      }

      /* Retro title effect */
      .pixel-title {
        text-shadow: 4px 4px 0px #000, -1px -1px 0px #00ffff;
        animation: float 3s ease-in-out infinite;
      }

      /* Scanline effect */
      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.15) 0px,
          transparent 2px,
          transparent 4px
        );
        pointer-events: none;
        z-index: 9999;
      }

      /* Pixel corners */
      .pixel-corner {
        position: relative;
      }

      .pixel-corner::before,
      .pixel-corner::after {
        content: '';
        position: absolute;
        width: 12px;
        height: 12px;
        background: #00ffff;
        border: 2px solid #000;
      }

      .pixel-corner::before {
        top: -6px;
        left: -6px;
      }

      .pixel-corner::after {
        bottom: -6px;
        right: -6px;
      }
    </style>
  </head>
  <body class="h-screen flex items-center justify-center p-2 overflow-hidden">
    <!-- Scanline overlay -->
    <div class="scanlines"></div>

    <div
      id="app"
      class="flex flex-col items-center w-full max-w-lg h-full justify-center"
      style="gap: 0.25rem"
    >
      <!-- Title and Score Area -->
      <h1
        class="text-sm md:text-base font-bold text-[#00ffff] text-center pixel-title"
        style="line-height: 1.3; margin-bottom: 0"
      >
        ⬤ CIRCLE QUEST ⬤
      </h1>

      <!-- Best Score Display -->
      <div
        id="bestScoreBadge"
        class="best-score-badge px-3 py-1 hidden"
        style="border-radius: 0; margin: 0.25rem 0"
      >
        <span class="text-black font-bold" style="font-size: 8px"
          >★ BEST: <span id="bestScoreValue">0</span>%</span
        >
      </div>

      <div class="flex flex-col items-center" style="gap: 0.25rem">
        <div
          id="scoreDisplay"
          class="text-2xl md:text-3xl font-bold text-[#ff0080] score-display"
          role="status"
          aria-live="polite"
          style="line-height: 1.2"
        >
          0%
        </div>
        <p
          id="messageDisplay"
          class="text-center px-2"
          style="line-height: 1.3; font-size: 8px; color: #00ff00"
        >
          DRAW CIRCLE!
        </p>
      </div>

      <!-- Canvas Container -->
      <div
        class="canvas-container w-full flex-shrink pixel-corner"
        style="margin: 0.25rem 0"
      >
        <canvas
          id="drawingCanvas"
          class="w-full h-full border-3 border-[#000]"
          style="border-radius: 0; border-width: 3px"
          role="img"
          aria-label="Drawing canvas for circle challenge"
          tabindex="0"
        ></canvas>
      </div>

      <!-- Controls -->
      <div
        class="flex gap-2 flex-wrap justify-center"
        style="margin: 0.25rem 0"
      >
        <button
          id="tryAgainButton"
          class="pixel-button px-4 py-1 bg-[#00ff00] text-black font-bold uppercase"
          style="border-radius: 0; font-size: 8px"
          aria-label="Reset and try drawing again"
        >
          ► RETRY
        </button>
        <button
          id="clearBestButton"
          class="pixel-button px-3 py-1 bg-[#ff0080] text-white font-bold hidden uppercase"
          style="border-radius: 0; font-size: 8px"
          aria-label="Clear best score"
        >
          ✕ CLEAR
        </button>
      </div>

      <p
        class="text-center"
        style="
          line-height: 1.3;
          font-size: 7px;
          color: #00ffff;
          margin: 0.25rem 0;
        "
      >
        HOLD + DRAG TO DRAW
      </p>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const tryAgainButton = document.getElementById('tryAgainButton');
        const bestScoreBadge = document.getElementById('bestScoreBadge');
        const bestScoreValue = document.getElementById('bestScoreValue');
        const clearBestButton = document.getElementById('clearBestButton');

        let isDrawing = false;
        let points = [];
        let bestScore = parseInt(
          localStorage.getItem('circleChallengeHighScore') || '0'
        );
        let animationFrameId = null;

        const MIN_POINTS_FOR_SCORE = 10;
        const SCORE_SCALE_FACTOR = 180; // Adjusted for better score distribution
        const REAL_TIME_UPDATE_INTERVAL = 3; // Update score every N points

        // Initialize best score display
        if (bestScore > 0) {
          bestScoreBadge.classList.remove('hidden');
          bestScoreValue.textContent = bestScore;
          clearBestButton.classList.remove('hidden');
        }

        // Set canvas size with proper device pixel ratio support
        const setCanvasSize = () => {
          const container = canvas.parentElement;
          const size = Math.min(container.clientWidth, container.clientHeight);
          const dpr = window.devicePixelRatio || 1;

          // Set display size
          canvas.style.width = size + 'px';
          canvas.style.height = size + 'px';

          // Set actual size in memory (scaled for retina displays)
          canvas.width = size * dpr;
          canvas.height = size * dpr;

          // Scale context to match device pixel ratio
          ctx.scale(dpr, dpr);

          // Set canvas logical size for calculations
          canvas.dataset.width = size;
          canvas.dataset.height = size;
        };

        // Unified event coordinate extraction
        const getEventCoordinates = (e) => {
          let clientX, clientY;
          if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
          } else {
            clientX = e.clientX;
            clientY = e.clientY;
          }
          return { clientX, clientY };
        };

        // Convert screen coordinates to canvas coordinates
        const getCanvasCoordinates = (clientX, clientY) => {
          const rect = canvas.getBoundingClientRect();
          const logicalWidth = parseFloat(canvas.dataset.width);
          const logicalHeight = parseFloat(canvas.dataset.height);

          const scaleX = logicalWidth / rect.width;
          const scaleY = logicalHeight / rect.height;

          return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY,
          };
        };

        // Start drawing
        const startDraw = (e) => {
          e.preventDefault();
          isDrawing = true;
          points = [];

          // Clear canvas
          const logicalWidth = parseFloat(canvas.dataset.width);
          const logicalHeight = parseFloat(canvas.dataset.height);
          ctx.clearRect(0, 0, logicalWidth, logicalHeight);
          ctx.beginPath();

          // Reset UI
          scoreDisplay.textContent = '0%';
          scoreDisplay.classList.remove('shake');
          messageDisplay.textContent = 'DRAWING...';
          messageDisplay.className = 'text-center px-2';
          messageDisplay.style.lineHeight = '1.3';
          messageDisplay.style.fontSize = '8px';
          messageDisplay.style.color = '#00ff00';

          const { clientX, clientY } = getEventCoordinates(e);
          const point = getCanvasCoordinates(clientX, clientY);
          points.push(point);
          ctx.moveTo(point.x, point.y);
        };

        // End drawing
        const endDraw = () => {
          if (!isDrawing) return;

          isDrawing = false;
          ctx.closePath();

          if (points.length > MIN_POINTS_FOR_SCORE) {
            const finalScore = calculateCircularity(points);
            updateScoreDisplay(finalScore);
            showFinalMessage(finalScore);

            // Update best score
            if (finalScore > bestScore) {
              bestScore = finalScore;
              localStorage.setItem('circleChallengeHighScore', bestScore);
              bestScoreValue.textContent = bestScore;
              bestScoreBadge.classList.remove('hidden');
              clearBestButton.classList.remove('hidden');

              // Celebrate new high score!
              if (finalScore >= 90) {
                createConfetti();
              }

              // Animate the badge
              bestScoreBadge.classList.add('shake');
              setTimeout(() => bestScoreBadge.classList.remove('shake'), 500);
            }
          } else {
            messageDisplay.textContent = 'TOO SMALL!';
            messageDisplay.className = 'text-center px-2';
            messageDisplay.style.lineHeight = '1.3';
            messageDisplay.style.fontSize = '8px';
            messageDisplay.style.color = '#ff0080';
          }
        };

        // Draw on canvas
        const draw = (e) => {
          if (!isDrawing) return;
          e.preventDefault();

          const { clientX, clientY } = getEventCoordinates(e);
          const point = getCanvasCoordinates(clientX, clientY);
          points.push(point);

          // Draw line segment with pixelated rendering
          ctx.lineTo(point.x, point.y);
          ctx.lineWidth = 6;
          ctx.lineCap = 'square';
          ctx.lineJoin = 'miter';
          ctx.strokeStyle = '#ff0080';
          ctx.stroke();

          // Real-time score update (throttled)
          if (
            points.length % REAL_TIME_UPDATE_INTERVAL === 0 &&
            points.length >= MIN_POINTS_FOR_SCORE
          ) {
            const currentScore = calculateCircularity(points);
            updateScoreDisplay(currentScore, false);
          }
        };

        // Calculate circularity score
        const calculateCircularity = (currentPoints) => {
          if (currentPoints.length < 3) return 0;

          // Calculate centroid
          const sumX = currentPoints.reduce((sum, p) => sum + p.x, 0);
          const sumY = currentPoints.reduce((sum, p) => sum + p.y, 0);
          const cx = sumX / currentPoints.length;
          const cy = sumY / currentPoints.length;

          // Calculate radii from centroid
          const radii = currentPoints.map((p) =>
            Math.sqrt(Math.pow(p.x - cx, 2) + Math.pow(p.y - cy, 2))
          );

          // Calculate mean radius
          const meanR = radii.reduce((sum, r) => sum + r, 0) / radii.length;
          if (meanR === 0) return 0;

          // Calculate standard deviation
          const variance =
            radii.reduce((sum, r) => sum + Math.pow(r - meanR, 2), 0) /
            radii.length;
          const stdDev = Math.sqrt(variance);

          // Calculate circularity index (coefficient of variation)
          const circularityIndex = stdDev / meanR;

          // Map to 0-100 score with exponential decay for better distribution
          let score =
            100 * Math.exp((-circularityIndex * SCORE_SCALE_FACTOR) / 100);

          return Math.max(0, Math.min(100, Math.round(score)));
        };

        // Update score display
        const updateScoreDisplay = (score, animate = true) => {
          scoreDisplay.textContent = `${score}%`;

          if (animate) {
            scoreDisplay.classList.remove('shake');
            requestAnimationFrame(() => {
              scoreDisplay.classList.add('shake');
            });
          }
        };

        // Show final message based on score
        const showFinalMessage = (score) => {
          let message, color;

          if (score >= 95) {
            message = '★★★ PERFECT! CIRCLE MASTER! ★★★';
            color = '#00ff00';
          } else if (score >= 85) {
            message = '★★ EXCELLENT! GREAT CIRCLE!';
            color = '#00ff00';
          } else if (score >= 70) {
            message = '★ NICE! PRETTY ROUND!';
            color = '#ffcc00';
          } else if (score >= 50) {
            message = '○ NEEDS WORK... MORE EGG!';
            color = '#ff8800';
          } else {
            message = "□ THAT'S A SQUARE! TRY AGAIN!";
            color = '#ff0080';
          }

          messageDisplay.textContent = message;
          messageDisplay.className = 'text-center px-2';
          messageDisplay.style.lineHeight = '1.3';
          messageDisplay.style.fontSize = '8px';
          messageDisplay.style.color = color;
        };

        // Create confetti animation for high scores
        const createConfetti = () => {
          const colors = [
            '#ff0080',
            '#00ff00',
            '#ffcc00',
            '#00ffff',
            '#ff8800',
          ];
          const confettiCount = 50;

          for (let i = 0; i < confettiCount; i++) {
            setTimeout(() => {
              const confetti = document.createElement('div');
              confetti.className = 'confetti';
              confetti.style.left = Math.random() * 100 + '%';
              confetti.style.backgroundColor =
                colors[Math.floor(Math.random() * colors.length)];
              confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
              confetti.style.animationDelay = Math.random() * 0.5 + 's';
              document.body.appendChild(confetti);

              setTimeout(() => confetti.remove(), 4000);
            }, i * 30);
          }
        };

        // Reset the app
        const resetApp = () => {
          const logicalWidth = parseFloat(canvas.dataset.width);
          const logicalHeight = parseFloat(canvas.dataset.height);
          ctx.clearRect(0, 0, logicalWidth, logicalHeight);
          points = [];
          isDrawing = false;
          scoreDisplay.textContent = '0%';
          scoreDisplay.classList.remove('shake');
          messageDisplay.textContent = 'DRAW CIRCLE!';
          messageDisplay.className = 'text-center px-2';
          messageDisplay.style.lineHeight = '1.3';
          messageDisplay.style.fontSize = '8px';
          messageDisplay.style.color = '#00ff00';
        };

        // Clear best score
        const clearBestScore = () => {
          if (confirm('CLEAR YOUR BEST SCORE?')) {
            bestScore = 0;
            localStorage.removeItem('circleChallengeHighScore');
            bestScoreBadge.classList.add('hidden');
            clearBestButton.classList.add('hidden');
          }
        };

        // Initialize
        setCanvasSize();

        // Event listeners
        window.addEventListener('resize', setCanvasSize);
        tryAgainButton.addEventListener('click', resetApp);
        clearBestButton.addEventListener('click', clearBestScore);

        // Mouse events
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', endDraw);

        // Touch events with proper prevention
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw, { passive: false });
        canvas.addEventListener('touchcancel', endDraw, { passive: false });

        // Keyboard support for accessibility
        canvas.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            resetApp();
            canvas.focus();
          }
        });

        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      });
    </script>
  </body>
</html>
